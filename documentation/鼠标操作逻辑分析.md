# 鼠标操作逻辑分析文档

## 概述

本文档详细说明项目中鼠标移动和点击的实现逻辑，包括核心接口、实现方式、使用场景和防检测机制。

---

## 1. 核心交互类

### 1.1 GenshinInteraction
**文件位置**: `ok.device.intercation.GenshinInteraction` (外部库)

**用途**: 
- 主要用于**相对鼠标移动**（视角旋转）
- 支持 PostMessage 后台消息发送
- 常用于执行路径中的视角调整

**关键方法**:
```python
def move_mouse_relative(dx: int, dy: int)
def do_move_mouse_relative(dx: int, dy: int)  # 直接移动，无灵敏度转换
```

**使用场景**:
- 护送任务中的视角旋转
- 自动寻路中的方向调整
- 鼠标抖动防检测

---

### 1.2 PyDirectInteraction
**文件位置**: `ok.device.intercation.PyDirectInteraction` (外部库)

**用途**:
- 用于**绝对位置**的鼠标移动和点击
- 当游戏窗口在前台时使用
- 适合 UI 交互场景

**关键方法**:
```python
def move(x: int, y: int)     # 移动到绝对位置
def click(down_time: float)   # 执行点击
```

**使用场景**:
- UI 按钮点击
- 迷宫解谜的路径拖拽

---

### 1.3 Win32 API 直接调用
**使用场景**: 一些特殊任务直接使用 Win32 API

```python
import win32api
import win32con

# 移动鼠标到绝对坐标
win32api.SetCursorPos((x, y))

# 鼠标按下
win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)

# 鼠标抬起
win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0, 0, 0)
```

**典型应用**: `AutoMazeTask` (迷宫解谜任务)

---

## 2. BaseDNATask 中的鼠标操作方法

### 2.1 相对移动 - move_mouse_relative()
**文件**: [src/tasks/BaseDNATask.py](../src/tasks/BaseDNATask.py#L621)

```python
def move_mouse_relative(self, dx, dy, use_aim_sensitivity=False, 
                       original_Xsensitivity=1.0, original_Ysensitivity=1.0):
    """
    相对位置移动鼠标（用于视角旋转）
    
    参数:
        dx, dy: 移动的像素偏移量
        use_aim_sensitivity: 是否使用瞄准灵敏度（否则使用视角灵敏度）
        original_Xsensitivity/Ysensitivity: 原始录制时的灵敏度
    
    功能:
        1. 根据当前游戏灵敏度转换移动量
        2. 如果窗口不在前台，自动置顶窗口
        3. 调用 GenshinInteraction 执行相对移动
    """
    dx, dy = self.calculate_sensitivity(dx, dy, use_aim_sensitivity, 
                                       original_Xsensitivity, original_Ysensitivity)
    self.try_bring_to_front()
    self.genshin_interaction.move_mouse_relative(int(dx), int(dy))
```

**灵敏度换算逻辑** (`calculate_sensitivity()`):
- 如果设置了"自动转换灵敏度"：
  - 从配置读取当前游戏灵敏度
  - 计算缩放因子：`game_sensitivity / original_sensitivity`
  - 转换移动量：`new_dx = dx * (game_Xsensitivity / original_Xsensitivity)`

---

### 2.2 绝对点击 - _perform_random_click()
**文件**: [src/tasks/BaseDNATask.py](../src/tasks/BaseDNATask.py#L366)

```python
def _perform_random_click(self, x_abs, y_abs, use_safe_move=False, 
                         safe_move_box=None, down_time=0.0, 
                         post_sleep=0.0, after_sleep=0.0, use_trajectory=True):
    """
    执行带随机延迟和轨迹移动的点击操作
    
    功能:
        1. 随机化点击前后的延迟时间（防检测）
        2. 根据窗口是否在前台选择交互方式：
           - 前台：使用 PyDirectInteraction + 贝塞尔曲线轨迹移动
           - 后台：使用 PostMessage（消息发送）
        3. 可选的"安全移动"：点击时将鼠标移到安全位置
        4. use_trajectory=True: 使用贝塞尔曲线轨迹（更真实）
    """
    _down_time = random.uniform(0.02, 0.08) if down_time == 0.0 else down_time
    _post_sleep = random.uniform(0.01, 0.04) if post_sleep <= 0 else post_sleep
    _after_sleep = random.uniform(0.01, 0.04) if after_sleep <= 0 else after_sleep
    
    self.sleep(_post_sleep)
    
    if not self.hwnd.is_foreground():  # 后台
        if use_safe_move:
            self.move_mouse_to_safe_position(boxes=safe_move_box)
        self.click(x, y, down_time=_down_time)  # PostMessage 点击
        if use_safe_move:
            self.move_back_from_safe_position()
    else:  # 前台
        if use_trajectory:
            # 使用贝塞尔曲线轨迹移动（新功能）
            self.move_mouse_with_trajectory(x, y)
            self.sleep(random.uniform(0.05, 0.08))
        else:
            # 直接移动（旧方式）
            self.pydirect_interaction.move(x, y)
            self.sleep(random.uniform(0.08, 0.12))
        self.pydirect_interaction.click(down_time=_down_time)
    
    self.sleep(_after_sleep)
```

---

### 2.3 贝塞尔曲线轨迹移动 - move_mouse_with_trajectory()
**文件**: [src/tasks/BaseDNATask.py](../src/tasks/BaseDNATask.py#L397)

```python
def move_mouse_with_trajectory(self, target_x, target_y, duration=None):
    """
    沿贝塞尔曲线轨迹移动鼠标到目标位置
    
    参数:
        target_x, target_y: 目标位置（游戏窗口相对坐标）
        duration: 移动总时长（秒），None则根据距离自动计算
    
    特点:
        1. 使用二次贝塞尔曲线生成自然轨迹
        2. 根据距离自动调整轨迹点数量
        3. 控制点随机偏移，使每次轨迹不同
        4. 末端加速，模拟真实人类行为
        5. 距离小于5像素直接移动
    """
    # 获取当前鼠标位置
    current_pos = win32api.GetCursorPos()
    
    # 转换目标位置为绝对坐标
    target_abs = self.executor.interaction.capture.get_abs_cords(int(target_x), int(target_y))
    
    # 计算距离
    distance = ((target_abs[0] - current_pos[0])**2 + (target_abs[1] - current_pos[1])**2)**0.5
    
    # 如果距离太小，直接移动
    if distance < 5:
        win32api.SetCursorPos(target_abs)
        return
    
    # 根据距离自动计算移动时长（每200像素约0.2秒）
    if duration is None:
        duration = max(0.1, min(0.5, distance / 1000))
    
    # 生成贝塞尔曲线轨迹
    trajectory = self._generate_bezier_curve(
        current_pos[0], current_pos[1],
        target_abs[0], target_abs[1]
    )
    
    # 沿轨迹移动
    points_count = len(trajectory)
    interval = duration / points_count
    
    for i, (x, y) in enumerate(trajectory):
        win32api.SetCursorPos((int(x), int(y)))
        
        # 最后几个点加快速度，模拟真实行为
        if i < points_count - 3:
            time.sleep(interval)
        else:
            time.sleep(interval * 0.5)
```

**算法说明**:
- **贝塞尔曲线公式**: `B(t) = (1-t)²P₀ + 2(1-t)tP₁ + t²P₂`
  - P₀: 起点
  - P₁: 控制点（中点 + 随机偏移）
  - P₂: 终点
  - t: 参数，从0到1

- **控制点偏移**: `offset = distance × 0.15 × random(-1, 1)`
- **轨迹点数**: `max(5, min(50, distance / 30))`
- **移动时长**: `max(0.1, min(0.5, distance / 1000))` 秒

---

### 2.4 辅助点击方法

#### click_box_random()
**功能**: 在指定 Box 区域内随机位置点击

```python
def click_box_random(self, box: Box, down_time=0.0, post_sleep=0.0, 
                    after_sleep=0.0, use_safe_move=False, 
                    safe_move_box=None, left_extend=0.0, right_extend=0.0, 
                    up_extend=0.0, down_extend=0.0):
    """
    在 Box 区域（可扩展边界）内随机点击
    
    参数:
        left_extend/right_extend/up_extend/down_extend: 
            相对屏幕宽高的扩展比例 (0.0-1.0)
    """
```

#### click_btn_random()
**功能**: 点击按钮右侧的随机位置（避免点击到图标本身）

---

## 3. 防鼠标干扰机制

### 3.1 安全位置移动
**文件**: [src/tasks/BaseDNATask.py](../src/tasks/BaseDNATask.py#L240)

```python
def move_mouse_to_safe_position(self, save_current_pos=True, boxes=None):
    """
    将鼠标移动到安全位置（通常是右下角），避免干扰操作
    
    配置项: '防止鼠标干扰' (config.py)
    默认位置: (0.95, 0.6) 相对坐标
    
    使用场景:
        - 任务启动时
        - 执行后台点击前
        - 特定场景下需要清空鼠标影响时
    """
    if self.afk_config["防止鼠标干扰"]:
        self.old_mouse_pos = win32api.GetCursorPos() if save_current_pos else None
        if self.rel_move_if_in_win(0.95, 0.6, boxes=boxes):
            pass
        else:
            self.old_mouse_pos = None

def move_back_from_safe_position(self):
    """恢复鼠标到原位置"""
    if self.afk_config["防止鼠标干扰"] and self.old_mouse_pos is not None:
        win32api.SetCursorPos(self.old_mouse_pos)
        self.old_mouse_pos = None
```

**相关配置** ([src/config.py](../src/config.py#L33)):
```python
'防止鼠标干扰': True,
'鼠标抖动': True,
'鼠标抖动锁定在窗口范围': True,
```

---

### 3.2 鼠标抖动防检测
**文件**: [src/tasks/BaseDNATask.py](../src/tasks/BaseDNATask.py#L723)

```python
def perform_mouse_jitter(current_drift):
    """
    执行微小的鼠标抖动，模拟真人操作
    
    逻辑:
        1. 计算当前的累积漂移量
        2. 如果漂移小于阈值(4)，生成较大的目标偏移(-3 ~ 3)
        3. 否则生成小的修正偏移(-1 ~ 1)
        4. 使用 do_move_mouse_relative() 执行移动
        5. 更新累积漂移
    
    防检测机制:
        - 随机方向和距离
        - 保持漂移在小范围内
        - 如果启用 "鼠标抖动锁定在窗口范围"，会先检查鼠标位置
    """
    if not self.afk_config.get("鼠标抖动", True):
        return current_drift
    
    if self.afk_config.get("鼠标抖动锁定在窗口范围", True):
        self.set_mouse_in_window()
    
    dist_sq = current_drift[0]**2 + current_drift[1]**2
    
    if dist_sq < 4:
        target_x = random.choice([-3, -2, 2, 3])
        target_y = random.choice([-3, -2, 2, 3])
    else:
        target_x = random.randint(-1, 1)
        target_y = random.randint(-1, 1)
    
    move_x = target_x - current_drift[0]
    move_y = target_y - current_drift[1]
    
    if move_x == 0 and move_y == 0:
        move_x = 1 if random.random() > 0.5 else -1
    
    self.genshin_interaction.do_move_mouse_relative(move_x, move_y)
    
    current_drift[0] += move_x
    current_drift[1] += move_y
    
    return current_drift
```

---

### 3.3 窗口范围检查

```python
def is_mouse_in_window(self) -> bool:
    """检查鼠标是否在游戏窗口内"""
    # 继承自 BaseTask

def set_mouse_in_window(self):
    """如果鼠标不在窗口内，将其移动到窗口内随机位置"""
    if self.is_mouse_in_window():
        return
    random_x = random.randint(self.width_of_screen(0.2), self.width_of_screen(0.8))
    random_y = random.randint(self.height_of_screen(0.2), self.height_of_screen(0.8))
    abs_pos = self.executor.interaction.capture.get_abs_cords(random_x, random_y)
    win32api.SetCursorPos(abs_pos)
```

---

## 4. 复杂任务中的鼠标操作

### 4.1 护送任务 (AutoEscortTask)
**文件**: [src/tasks/fullauto/AutoEscortTask.py](../src/tasks/fullauto/AutoEscortTask.py)

#### 视角旋转
```python
def execute_mouse_rotation(self, action):
    """
    执行鼠标视角旋转动作
    
    动作格式 (JSON):
    {
        "type": "mouse_rotation",
        "direction": "left|right|up|down",
        "angle": 角度值,
        "sensitivity": 灵敏度 (默认10)
    }
    
    计算方式:
        pixels = angle * sensitivity
        
        方向映射:
            left  -> dx=-pixels, dy=0
            right -> dx=pixels, dy=0
            up    -> dx=0, dy=-pixels
            down  -> dx=0, dy=pixels
    """
    direction = action.get("direction", "up")
    angle = action.get("angle", 0)
    sensitivity = action.get("sensitivity", 10)
    
    pixels = angle * sensitivity
    
    if direction == "left":
        dx, dy = -pixels, 0
    elif direction == "right":
        dx, dy = pixels, 0
    elif direction == "up":
        dx, dy = 0, -pixels
    elif direction == "down":
        dx, dy = 0, pixels
    else:
        logger.warning(f"未知的鼠标方向: {direction}")
        return
    
    self.move_mouse_relative(dx, dy)
```

#### 鼠标按键操作
```python
def execute_path_segment(self, segment, skip_first_delay=False):
    """
    执行路径片段中的动作
    
    支持的鼠标动作:
        - mouse_down: 按下鼠标键
        - mouse_up: 释放鼠标键
        - mouse_rotation: 视角旋转
    """
    action_type = action.get("type")
    
    if action_type == "mouse_down":
        button = action.get("button", "left")
        self.mouse_down(key=button)
        logger.debug(f"按下鼠标: {button}")
    
    elif action_type == "mouse_up":
        button = action.get("button", "left")
        self.mouse_up(key=button)
        logger.debug(f"释放鼠标: {button}")
    
    elif action_type == "mouse_rotation":
        self.execute_mouse_rotation(action)
```

---

### 4.2 路径导入任务 (ImportTask)
**文件**: [src/tasks/fullauto/ImportTask.py](../src/tasks/fullauto/ImportTask.py)

支持从外部 JSON 文件导入鼠标操作序列：

```python
def execute_action(self, action):
    """
    分发动作执行
    
    支持的动作类型:
        - mouse_move: 相对移动
        - mouse_rotation: 视角旋转
        - mouse_down/mouse_up: 按下/释放鼠标键
        - key_down/key_up: 键盘操作
    """
    action_type = action['type']
    
    if action_type == "mouse_move":
        self.move_mouse_relative(action['dx'], action['dy'], 
                                self.original_Xsensitivity, 
                                self.original_Ysensitivity)
    
    elif action_type == "mouse_rotation":
        self.execute_mouse_rotation(action)
    
    elif action_type in ("mouse_down", "mouse_up"):
        self._handle_mouse_click(action_type, action['button'])
```

**JSON 格式示例** ([mod/builtin/escort_paths.json](../mod/builtin/escort_paths.json)):
```json
[
  {
    "type": "mouse_down",
    "delay": 0.1142,
    "button": "left"
  },
  {
    "type": "mouse_rotation",
    "delay": 0.1417,
    "angle": 2,
    "direction": "right",
    "sensitivity": 10
  },
  {
    "type": "mouse_up",
    "delay": 0.4031,
    "button": "left"
  }
]
```

---

### 4.3 迷宫解谜 (AutoMazeTask)
**文件**: [src/tasks/trigger/AutoMazeTask.py](../src/tasks/trigger/AutoMazeTask.py)

使用 Win32 API 直接控制鼠标进行拖拽：

```python
def solve_puzzle(self, puzzle_name):
    """
    执行 puzzle 解密（需要游戏窗口在前台）
    
    步骤:
        1. 从配置读取路径坐标数组
        2. 缩放坐标到当前分辨率
        3. 在第一个点按下鼠标左键
        4. 依次拖拽到每个路径点
        5. 释放鼠标左键
    """
    path = puzzle_data["coordinates"]  # [[x1,y1], [x2,y2], ...]
    move_delay = self.config.get("移动延迟（秒）", 0.1)
    
    # 缩放坐标
    scale_x = hwnd_window.width / 1920
    scale_y = hwnd_window.height / 1080
    
    # 第一个点：按下
    x = int(path[0][0] * scale_x)
    y = int(path[0][1] * scale_y)
    abs_x, abs_y = hwnd_window.get_abs_cords(x, y)
    
    win32api.SetCursorPos((abs_x, abs_y))
    self.sleep_random(0.1)
    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)
    self.sleep_random(move_delay)
    
    # 中间点：拖拽
    for i in range(1, len(path)):
        x = int(path[i][0] * scale_x)
        y = int(path[i][1] * scale_y)
        abs_x, abs_y = hwnd_window.get_abs_cords(x, y)
        win32api.SetCursorPos((abs_x, abs_y))
        self.sleep_random(move_delay)
    
    # 释放
    win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0, 0, 0)
```

---

### 4.4 自动穿引共鸣 (AutoMoveTask)
**文件**: [src/tasks/trigger/AutoMoveTask.py](../src/tasks/trigger/AutoMoveTask.py)

自动长按左键的触发任务：

```python
@contextmanager
def left_click_scope(self):
    """上下文管理器：自动管理鼠标按下/释放"""
    self.mouse_down()
    try:
        yield
    finally:
        self.mouse_up()

def do_move(self):
    """执行移动循环"""
    try:
        with self.left_click_scope():
            self.trig_sleep_check(self.config.get('按下时间', 0.50))
        self.trig_sleep_check(self.config.get("间隔时间", 0.50))
    except TriggerDeactivateException:
        self.running = False
        return False
```

**监听器**:
```python
def on_global_click(self, x, y, button, pressed):
    """
    全局鼠标点击监听
    
    功能:
        - X2 鼠标侧键: 激活任务
        - 左键: 中断任务
    """
    activate_key_name = self.config.get('激活键', 'x2')
    activate_button = key_map.get(activate_key_name)
    
    if pressed:
        if button == activate_button:
            self.signal = True  # 激活信号
        elif self.manual_activate and button == mouse.Button.left:
            self.signal_interrupt = True  # 中断信号
```

---

## 5. 全局监听系统

### 5.1 Globals 类
**文件**: [src/globals.py](../src/globals.py)

```python
class Globals(QObject):
    # Qt 信号
    clicked = Signal(int, int, object, bool)
    pressed = Signal(object)
    
    def init_pynput(self):
        """初始化 pynput 监听器"""
        from pynput import mouse, keyboard
        
        self.pynput_mouse = mouse.Listener(on_click=self.on_click)
        self.pynput_keyboard = keyboard.Listener(on_press=self.on_press)
        
        self.pynput_mouse.start()
        self.pynput_keyboard.start()
    
    def on_click(self, x, y, button, pressed):
        """鼠标点击回调，发射信号"""
        self.clicked.emit(x, y, button, pressed)
    
    def on_press(self, key):
        """键盘按下回调，发射信号"""
        self.pressed.emit(key)
```

### 5.2 监听器连接
**BaseListenerTask**:
```python
def try_connect_listener(self):
    """连接全局监听信号到任务方法"""
    og.my_app.clicked.connect(self.on_global_click)
    og.my_app.pressed.connect(self.on_global_press)

def try_disconnect_listener(self):
    """断开连接"""
    og.my_app.clicked.disconnect(self.on_global_click)
    og.my_app.pressed.disconnect(self.on_global_press)
```

---

## 6. 配置与灵敏度管理

### 6.1 相关配置项
**文件**: [src/config.py](../src/config.py)

```python
# 挂机设置
'防止鼠标干扰': True,
'鼠标抖动': True,
'鼠标抖动锁定在窗口范围': True,

# 灵敏度配置 (Game Sensitivity Config)
'自动转换灵敏度': False,
'X-axis sensitivity': 1.0,
'Y-axis sensitivity': 1.0,
'Aim X-axis sensitivity': 1.0,
'Aim Y-axis sensitivity': 1.0,

# 交互方式
'interaction': 'PostMessage',  # 支持大多数PC游戏后台点击
```

### 6.2 灵敏度换算
当"自动转换灵敏度"开启时：
- **原理**: 录制路径时使用的灵敏度可能与当前游戏设置不同
- **公式**: `new_dx = dx / (game_sensitivity / original_sensitivity)`
- **示例**: 
  - 录制时灵敏度: 1.0
  - 当前灵敏度: 0.5
  - 原始移动: 100 像素
  - 实际移动: 100 / (0.5 / 1.0) = 200 像素

---

## 7. 常用鼠标操作 API 总结

### 7.1 相对移动（视角）
```python
# 标准方法（带灵敏度转换）
self.move_mouse_relative(dx, dy)

# 直接移动（无转换）
self.genshin_interaction.do_move_mouse_relative(dx, dy)

# 视角旋转（角度转像素）
pixels = angle * sensitivity
self.move_mouse_relative(pixels, 0)  # 水平
self.move_mouse_relative(0, pixels)  # 垂直
```

### 7.2 绝对点击
```python
# 在 Box 内随机点击（默认使用轨迹）
self.click_box_random(box)

# 点击按钮右侧（默认使用轨迹）
self.click_btn_random(box)

# 相对坐标点击（默认使用轨迹）
self.click_relative_random(0.5, 0.5, 0.6, 0.6)

# 精确坐标点击（内部方法）
self._perform_random_click(x, y, use_trajectory=True)  # 使用轨迹（推荐）
self._perform_random_click(x, y, use_trajectory=False) # 直接移动（旧方式）
```

### 7.3 轨迹移动（新增）
```python
# 带贝塞尔曲线轨迹的鼠标移动
self.move_mouse_with_trajectory(target_x, target_y)

# 指定移动时长
self.move_mouse_with_trajectory(target_x, target_y, duration=0.3)

# 生成贝塞尔曲线轨迹点（底层方法）
trajectory = self._generate_bezier_curve(start_x, start_y, end_x, end_y)
```

### 7.4 鼠标按键
```python
# 按下
self.mouse_down(key="left")   # left, right, middle, x1, x2

# 释放
self.mouse_up(key="left")

# 上下文管理器
with self.left_click_scope():
    # 按住期间的操作
    self.sleep(1.0)
# 自动释放
```

### 7.4 防检测工具
```python
# 移动到安全位置
self.move_mouse_to_safe_position()
self.move_back_from_safe_position()

# 检查鼠标位置
if self.is_mouse_in_window():
    self.set_mouse_in_window()

# 鼠标抖动（自动在 fidget_action 中调用）
# 无需手动调用，通过配置控制
```

---

## 8. 典型使用流程

### 8.1 UI 点击流程
```python
def click_start_button(self):
    # 1. 查找按钮
    start_box = self.find_start_btn()
    if not start_box:
        return False
    
    # 2. 移动鼠标到安全位置（可选）
    self.move_mouse_to_safe_position()
    
    # 3. 点击按钮右侧随机位置（默认使用贝塞尔曲线轨迹）
    self.click_btn_random(start_box, after_sleep=1.0)
    
    # 4. 恢复鼠标（可选）
    self.move_back_from_safe_position()
    
    return True
```

**说明**: 所有点击方法（`click_box_random`、`click_btn_random`、`click_relative_random`）默认在前台模式下使用贝塞尔曲线轨迹移动。

### 8.2 视角调整流程
```python
def adjust_camera_view(self):
    # 1. 确保窗口在前台
    self.try_bring_to_front()
    
    # 2. 水平旋转 90 度
    angle = 90
    sensitivity = 10
    pixels = angle * sensitivity
    self.move_mouse_relative(pixels, 0)
    
    # 3. 等待视角稳定
    self.sleep(0.5)
```

### 8.3 路径执行流程
```python
def execute_recorded_path(self, actions):
    for action in actions:
        action_type = action['type']
        delay = action.get('delay', 0)
        
        # 延迟
        if delay > 0:
            self.sleep(delay)
        
        # 执行动作
        if action_type == "mouse_rotation":
            self.execute_mouse_rotation(action)
        elif action_type == "mouse_down":
            self.mouse_down(key=action['button'])
        elif action_type == "mouse_up":
            self.mouse_up(key=action['button'])
        elif action_type == "key_down":
            self.send_key_down(action['key'])
        elif action_type == "key_up":
            self.send_key_up(action['key'])
```

---

## 9. 注意事项

### 9.1 前台 vs 后台
- **前台窗口**: 
  - 使用 `PyDirectInteraction`
  - 支持直接鼠标操作
  - 适合 UI 交互

- **后台窗口**:
  - 使用 `PostMessage` (继承自 BaseTask)
  - 支持在后台发送消息
  - 适合自动化脚本

### 9.2 灵敏度问题
- 录制路径时记录灵敏度
- 回放时自动转换（如果启用）
- 不同角色可能需要不同配置

### 9.3 防检测最佳实践
1. 启用"鼠标抖动"
2. 使用随机延迟
3. 点击使用随机位置
4. **使用贝塞尔曲线轨迹移动（默认启用）**
5. 避免固定的操作顺序
6. 模拟人类操作节奏

**轨迹移动的优势**:
- ✅ 模拟真实人类鼠标移动路径
- ✅ 每次轨迹都不同（控制点随机偏移）
- ✅ 末端加速效果（更自然）
- ✅ 根据距离自动调整速度和点数
- ✅ 可选择性禁用（use_trajectory=False）

### 9.4 坐标系统
- **相对坐标**: 0.0 ~ 1.0（屏幕百分比）
- **绝对坐标**: 像素值
- **Box 坐标**: 相对于游戏窗口左上角

---

## 10. 相关文件清单

### 核心文件
- `src/tasks/BaseDNATask.py` - 基础鼠标操作方法
- `src/globals.py` - 全局监听系统
- `src/config.py` - 配置管理

### 任务实现
- `src/tasks/fullauto/AutoEscortTask.py` - 护送任务（视角旋转）
- `src/tasks/fullauto/ImportTask.py` - 路径导入
- `src/tasks/trigger/AutoMazeTask.py` - 迷宫解谜（拖拽）
- `src/tasks/trigger/AutoMoveTask.py` - 自动穿引（长按）

### 数据文件
- `mod/builtin/escort_paths.json` - 护送路径定义
- `mod/builtin/puzzle_paths.json` - 解谜路径定义

---

## 附录: 鼠标操作决策树

```
需要鼠标操作？
│
├─ 视角旋转（相对移动）
│   └─ move_mouse_relative(dx, dy)
│       └─ GenshinInteraction.move_mouse_relative()
│
├─ UI 点击
│   ├─ 后台？
│   │   └─ self.click() (PostMessage)
│   └─ 前台？
│       └─ PyDirectInteraction.move() + click()
│
├─ 拖拽操作
│   └─ win32api.SetCursorPos() + mouse_event()
│
└─ 防检测
    ├─ move_mouse_to_safe_position()
    ├─ 鼠标抖动（自动）
    └─ 随机延迟（自动）
```

---

## 版本信息
- 文档创建日期: 2026-02-13
- 基于代码版本: ok-duet-night-abyss-master
- 分析工具: GitHub Copilot + 代码审查

---

**结束**
